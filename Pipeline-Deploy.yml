trigger: none
pr: none

# SIT-only pipeline using Activate-SIT library values

parameters:
  - name: releaseTo
    type: string
    default: 'KB'
    values: ['KB','BB']

  - name: SourceRepo
    displayName: 'Enter full UNC FQDN Path of the x64 MSI (DO NOT add trailing "\" e.g. \\kbshares.corp.bank.nzpfs.co.nz\releases\_Drop\Activate)'
    type: string
    default: ''   # leave blank to skip Upload_MSI stage

variables:
  # Imports from Library â†’ Activate-SIT:
  # MECM_ApplicationFolderpath, MECM_MsiFolderLocation, MECM_PreProdSiteServer,
  # MECM_PVTCollection, MECM_ScheduledCacheTime, MECM_ScheduledInstallTime,
  # MECM_SITContentDistributionPoints, MECM_SITLimitingCollectionName, MECM_SITSoftwareCentreCollection
  - group: Activate-SIT

  - name: vmImage
    value: 'windows-2022'

stages:
  # 0) Detect MSI ProductVersion -> revisionVersion
  - stage: Detect_Version
    displayName: 'Detect MSI ProductVersion'
    jobs:
      - job: SetVersion
        displayName: 'Read version from MSI'
        pool: { vmImage: $(vmImage) }
        steps:
          - task: PowerShell@2
            name: detect
            displayName: 'Detect ProductVersion from MSI'
            inputs:
              filePath: 'scripts/Detect-MsiVersion.ps1'
              arguments: >
                -Folder "$(MECM_MsiFolderLocation)"
                -Filter "Activate*.msi"
                -VariableName "revisionVersion"
                -SetBuildNumber
              pwsh: false   # use Windows PowerShell for WindowsInstaller COM

  # (Optional) 1) Upload MSI from UNC if provided
  # Only include this stage if SourceRepo is not empty
  - ${{ if ne(parameters.SourceRepo, '') }}:
    - template: Template-PublishArtifact.yml
      parameters:
        stageName: 'Upload_MSI'
        stageDisplayName: 'Upload MSI'
        SourceRepo: ${{ parameters.SourceRepo }}
        envName: 'PRD-WLG'

  # 2) Bootstrap: copy PS scripts for templates
  - stage: Bootstrap_Scripts
    displayName: 'Bootstrap scripts'
    dependsOn:
      - Detect_Version
      # Include Upload_MSI in the dependency graph only if it exists
      - ${{ if ne(parameters.SourceRepo, '') }}: Upload_MSI
    jobs:
      - job: Copy
        pool: { vmImage: $(vmImage) }
        steps:
          - powershell: |
              New-Item -ItemType Directory -Path "$(Pipeline.Workspace)\Cache" -Force | Out-Null
              Copy-Item "$(Build.SourcesDirectory)\scripts\*.ps1" "$(Pipeline.Workspace)\Cache" -Force
            displayName: 'Copy PS scripts to $(Pipeline.Workspace)\Cache'

  # 3) Create/brand/distribute the application (SIT)
  - template: ../templates/MECMApplicationTemplate.yml
    parameters:
      dryRun: False
      taskGroupName: "Scheduled${{ parameters.releaseTo }}"
      revisionVersion: $[ stageDependencies.Detect_Version.SetVersion.outputs['detect.revisionVersion'] ]
      releaseTo: ${{ parameters.releaseTo }}
      sourceFolder: '$(Build.SourcesDirectory)\InTouch Client'
      scriptsFolder: $(Pipeline.Workspace)\Cache
      mecmSiteServer: $(MECM_PreProdSiteServer)
      msiFolderLocation: $(MECM_MsiFolderLocation)
      applicationFolderPath: $(MECM_ApplicationFolderpath)
      contentDistributionPoints: $(MECM_SITContentDistributionPoints)

  # 4) Make application Available to PVT users (SIT)
  - template: ../templates/MECMAvailableDeploymentTemplate.yml
    parameters:
      dryRun: False
      taskGroupName: "PVT${{ parameters.releaseTo }}"
      revisionVersion: $[ stageDependencies.Detect_Version.SetVersion.outputs['detect.revisionVersion'] ]
      releaseTo: ${{ parameters.releaseTo }}
      scriptsFolder: $(Pipeline.Workspace)\Cache
      mecmSiteServer: $(MECM_PreProdSiteServer)
      limitingCollectionName: $(MECM_SITLimitingCollectionName)
      userCollectionName: $(MECM_PVTCollection)
      scheduledInstallTime: $(MECM_ScheduledCacheTime)   # "Now" from Library
      refreshDeviceCollection: false

  # 5) Make application Required for SIT groups (scheduled install)
  - template: ../templates/MECMRequiredDeploymentTemplate.yml
    parameters:
      dryRun: False
      taskGroupName: "Scheduled${{ parameters.releaseTo }}"
      revisionVersion: $[ stageDependencies.Detect_Version.SetVersion.outputs['detect.revisionVersion'] ]
      releaseTo: ${{ parameters.releaseTo }}
      scriptsFolder: $(Pipeline.Workspace)\Cache
      mecmSiteServer: $(MECM_PreProdSiteServer)
      limitingCollectionName: $(MECM_SITLimitingCollectionName)
      userCollectionName: $(MECM_SITSoftwareCentreCollection)   # "All Users" per Library
      scheduledCacheTime: $(MECM_ScheduledCacheTime)            # "Now" per Library
      scheduledInstallTime: $(MECM_ScheduledInstallTime)        # "Now" per Library
