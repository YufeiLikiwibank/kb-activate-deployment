trigger: none
pr: none

# SIT-only pipeline with brand subfolder under MECM_MsiFolderLocation

parameters:
  - name: releaseTo
    type: string
    default: 'KB'
    values: ['KB','BB']

  - name: SourceRepo
    displayName: 'Full UNC path of the MSI repo (no trailing "\") e.g. \\kbshares.corp.bank.nzpfs.co.nz\releases\_Drop\Activate'
    type: string
    default: ''

variables:
  # From Library → Activate-SIT:
  # MECM_ApplicationFolderpath, MECM_MsiFolderLocation, MECM_PreProdSiteServer,
  # MECM_PVTCollection, MECM_ScheduledCacheTime, MECM_ScheduledInstallTime,
  # MECM_SITContentDistributionPoints, MECM_SITLimitingCollectionName, MECM_SITSoftwareCentreCollection
  - group: Activate-SIT

  - name: vmImage
    value: 'windows-2022'

  # Compile-time brand folder name
  - ${{ if eq(parameters.releaseTo, 'KB') }}:
    - name: BrandFolder
      value: 'ActivateKB'
  - ${{ if eq(parameters.releaseTo, 'BB') }}:
    - name: BrandFolder
      value: 'ActivateBB'

  # Effective MSI directory used by all downstream templates
  - name: Effective_MsiFolderLocation
    value: '$(MECM_MsiFolderLocation)\$(BrandFolder)'

stages:
  # 0) Copy brand MSI to MECM_MsiFolderLocation\<BrandFolder>
  - stage: Upload_MSI
    displayName: 'Copy brand MSI → $(Effective_MsiFolderLocation)'
    jobs:
      - job: CopyFromUNC
        displayName: 'Copy KB/BB MSI'
        pool: { vmImage: $(vmImage) }
        steps:
          - task: PowerShell@2
            name: copy
            displayName: 'Copy brand MSI to destination'
            inputs:
              filePath: 'scripts/UploadMSI.ps1'
              arguments: >
                -SourceRoot "${{ parameters.SourceRepo }}"
                -DestinationRoot "$(MECM_MsiFolderLocation)"
                -Brand "${{ parameters.releaseTo }}"
              pwsh: false

  # 1) Detect MSI ProductVersion from the brand folder → $(revisionVersion)
  - stage: Detect_Version
    displayName: 'Detect MSI ProductVersion'
    dependsOn: Upload_MSI
    jobs:
      - job: SetVersion
        displayName: 'Read version from MSI'
        pool: { vmImage: $(vmImage) }
        steps:
          - task: PowerShell@2
            name: detect
            displayName: 'Detect ProductVersion from MSI'
            inputs:
              filePath: 'scripts/Detect-MsiVersion.ps1'
              arguments: >
                -Folder "$(Effective_MsiFolderLocation)"
                -Filter "*.msi"
                -VariableName "revisionVersion"
                -SetBuildNumber
              pwsh: false   # use Windows PowerShell for WindowsInstaller COM

  # 2) Bootstrap: copy PS scripts for downstream templates
  - stage: Bootstrap_Scripts
    displayName: 'Bootstrap scripts'
    dependsOn:
      - Upload_MSI
      - Detect_Version
    jobs:
      - job: Copy
        pool: { vmImage: $(vmImage) }
        steps:
          - powershell: |
              New-Item -ItemType Directory -Path "$(Pipeline.Workspace)\Cache" -Force | Out-Null
              Copy-Item "$(Build.SourcesDirectory)\scripts\*.ps1" "$(Pipeline.Workspace)\Cache" -Force
            displayName: 'Copy PS scripts to $(Pipeline.Workspace)\Cache'

  # 3) Create/brand/distribute the application (shared DPs/collections)
  - template: ../templates/MECMApplicationTemplate.yml
    parameters:
      dryRun: False
      taskGroupName: "Scheduled${{ parameters.releaseTo }}"
      revisionVersion: $[ stageDependencies.Detect_Version.SetVersion.outputs['detect.revisionVersion'] ]
      releaseTo: ${{ parameters.releaseTo }}
      sourceFolder: '$(Build.SourcesDirectory)\InTouch Client'
      scriptsFolder: $(Pipeline.Workspace)\Cache
      mecmSiteServer: $(MECM_PreProdSiteServer)
      msiFolderLocation: $(Effective_MsiFolderLocation)          # brand subfolder
      applicationFolderPath: $(MECM_ApplicationFolderpath)
      contentDistributionPoints: $(MECM_SITContentDistributionPoints)

  # 4) Make application Available to PVT users (shared)
  - template: ../templates/MECMAvailableDeploymentTemplate.yml
    parameters:
      dryRun: False
      taskGroupName: "PVT${{ parameters.releaseTo }}"
      revisionVersion: $[ stageDependencies.Detect_Version.SetVersion.outputs['detect.revisionVersion'] ]
      releaseTo: ${{ parameters.releaseTo }}
      scriptsFolder: $(Pipeline.Workspace)\Cache
      mecmSiteServer: $(MECM_PreProdSiteServer)
      limitingCollectionName: $(MECM_SITLimitingCollectionName)
      userCollectionName: $(MECM_PVTCollection)
      scheduledInstallTime: $(MECM_ScheduledCacheTime)
      refreshDeviceCollection: false

  # 5) Make application Required for SIT groups (shared)
  - template: ../templates/MECMRequiredDeploymentTemplate.yml
    parameters:
      dryRun: False
      taskGroupName: "Scheduled${{ parameters.releaseTo }}"
      revisionVersion: $[ stageDependencies.Detect_Version.SetVersion.outputs['detect.revisionVersion'] ]
      releaseTo: ${{ parameters.releaseTo }}
      scriptsFolder: $(Pipeline.Workspace)\Cache
      mecmSiteServer: $(MECM_PreProdSiteServer)
      limitingCollectionName: $(MECM_SITLimitingCollectionName)
      userCollectionName: $(MECM_SITSoftwareCentreCollection)
      scheduledCacheTime: $(MECM_ScheduledCacheTime)
      scheduledInstallTime: $(MECM_ScheduledInstallTime)
