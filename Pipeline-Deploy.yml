trigger: none
pr: none

parameters:
  - name: releaseTo
    type: string
    default: 'KB'
    values: ['KB','BB']
  - name: SourceRepo
    displayName: 'Full UNC path of the MSI repo (no trailing "\") e.g. \\kbshares.corp.bank.nzpfs.co.nz\releases\_Drop\Activate'
    type: string
    default: ''

variables:
  - group: Activate-SIT   # provides MECM_* variables

  - name: vmImage
    value: 'windows-2022'

  # Brand subfolder name (compile-time)
  - ${{ if eq(parameters.releaseTo, 'KB') }}:
    - name: BrandFolder
      value: 'ActivateKB'
  - ${{ if eq(parameters.releaseTo, 'BB') }}:
    - name: BrandFolder
      value: 'ActivateBB'

  # Effective MSI directory used by both scripts/templates
  - name: Effective_MsiFolderLocation
    value: '$(MECM_MsiFolderLocation)\$(BrandFolder)'
    
# 0) Copy brand MSI to MECM_MsiFolderLocation\<BrandFolder>
stage: Upload_MSI
  displayName: '[SRE-SIT] Copy MSI'
  jobs:
    - deployment: CopyFromUNC
      displayName: 'Copy KB/BB MSI'
      environment:
        name: 'SRE-SIT'
        resourceType: virtualMachine
        tags: 'Activate'
      strategy:
        runOnce:
          deploy:
            steps:
              - checkout: self          # <-- make sure the repo is present on the VM
              - powershell: |
                  Write-Host "Repo root: $(Build.SourcesDirectory)"
                  Get-ChildItem -Path "$(Build.SourcesDirectory)\scripts" -Force
                displayName: 'Sanity: list scripts folder'

              - task: PowerShell@2
                name: copy
                displayName: 'Copy brand MSI to destination'
                inputs:
                  filePath: '$(Build.SourcesDirectory)\scripts\UploadMSI.ps1'   # <-- absolute path
                  arguments: >
                    -SourceRoot "${{ parameters.SourceRepo }}"
                    -DestinationRoot "$(MECM_MsiFolderLocation)"
                    -Brand "${{ parameters.releaseTo }}"
                pwsh: false

# 1) Detect MSI ProductVersion â†’ $(revisionVersion)
- stage: Detect_Version
  displayName: '[SRE-SIT] Detect MSI ProductVersion'
  dependsOn: Upload_MSI
  jobs:
    - deployment: SetVersion
      displayName: 'Read ProductVersion'
      environment:
        name: 'SRE-SIT'
        resourceType: virtualMachine
        tags: 'Activate'
      strategy:
        runOnce:
          deploy:
            steps:
              - checkout: self
              - task: PowerShell@2
                name: detect
                displayName: 'Detect ProductVersion from MSI'
                inputs:
                  filePath: '$(Build.SourcesDirectory)\scripts\Detect-MsiVersion.ps1'
                  arguments: >
                    -Folder "$(Effective_MsiFolderLocation)"
                    -Filter "*.msi"
                    -VariableName "revisionVersion"
                    -SetBuildNumber
                pwsh: false

# 2) Bootstrap: copy PS helper scripts
- stage: Bootstrap_Scripts
  displayName: '[SRE-SIT] Bootstrap scripts'
  dependsOn: [Upload_MSI, Detect_Version]
  jobs:
    - deployment: CopyHelpers
      environment:
        name: 'SRE-SIT'
        resourceType: virtualMachine
        tags: 'Activate'
      strategy:
        runOnce:
          deploy:
            steps:
              - checkout: self
              - powershell: |
                  New-Item -ItemType Directory -Path "$(Pipeline.Workspace)\Cache" -Force | Out-Null
                  Copy-Item "$(Build.SourcesDirectory)\scripts\*.ps1" "$(Pipeline.Workspace)\Cache" -Force
                displayName: 'Copy PS scripts to $(Pipeline.Workspace)\Cache'


  # # 3) Create/brand/distribute the application (shared DPs/collections)
  # - template: ../templates/MECMApplicationTemplate.yml
  #   parameters:
  #     dryRun: False
  #     taskGroupName: "Scheduled${{ parameters.releaseTo }}"
  #     revisionVersion: $[ stageDependencies.Detect_Version.SetVersion.outputs['detect.revisionVersion'] ]
  #     releaseTo: ${{ parameters.releaseTo }}
  #     sourceFolder: '$(Build.SourcesDirectory)\InTouch Client'
  #     scriptsFolder: $(Pipeline.Workspace)\Cache
  #     mecmSiteServer: $(MECM_PreProdSiteServer)
  #     msiFolderLocation: $(Effective_MsiFolderLocation)          # brand subfolder
  #     applicationFolderPath: $(MECM_ApplicationFolderpath)
  #     contentDistributionPoints: $(MECM_SITContentDistributionPoints)

  # # 4) Make application Available to PVT users (shared)
  # - template: ../templates/MECMAvailableDeploymentTemplate.yml
  #   parameters:
  #     dryRun: False
  #     taskGroupName: "PVT${{ parameters.releaseTo }}"
  #     revisionVersion: $[ stageDependencies.Detect_Version.SetVersion.outputs['detect.revisionVersion'] ]
  #     releaseTo: ${{ parameters.releaseTo }}
  #     scriptsFolder: $(Pipeline.Workspace)\Cache
  #     mecmSiteServer: $(MECM_PreProdSiteServer)
  #     limitingCollectionName: $(MECM_SITLimitingCollectionName)
  #     userCollectionName: $(MECM_PVTCollection)
  #     scheduledInstallTime: $(MECM_ScheduledCacheTime)
  #     refreshDeviceCollection: false

  # # 5) Make application Required for SIT groups (shared)
  # - template: ../templates/MECMRequiredDeploymentTemplate.yml
  #   parameters:
  #     dryRun: False
  #     taskGroupName: "Scheduled${{ parameters.releaseTo }}"
  #     revisionVersion: $[ stageDependencies.Detect_Version.SetVersion.outputs['detect.revisionVersion'] ]
  #     releaseTo: ${{ parameters.releaseTo }}
  #     scriptsFolder: $(Pipeline.Workspace)\Cache
  #     mecmSiteServer: $(MECM_PreProdSiteServer)
  #     limitingCollectionName: $(MECM_SITLimitingCollectionName)
  #     userCollectionName: $(MECM_SITSoftwareCentreCollection)
  #     scheduledCacheTime: $(MECM_ScheduledCacheTime)
  #     scheduledInstallTime: $(MECM_ScheduledInstallTime)
